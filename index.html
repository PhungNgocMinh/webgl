<!DOCTYPE html>
<html lang="en">
<head>
    <title>Minh's website</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!--    Bootstrap via CDN   -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
    <!--    Prism CSS   -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <!--    Prism JS    -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <!--    Prism JS normalize whitepsaces -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/normalize-whitespace/prism-normalize-whitespace.min.js"></script>
    <!--    Prism JS line numbers -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
    <!--    Vanta JS Background -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/vanta@latest/dist/vanta.net.min.js"></script>
	
    <link rel="stylesheet" href="style.css">

</head>
<body id="background">

	<script>
		VANTA.NET({
		el: "#background",
		mouseControls: true,
		touchControls: true,
		gyroControls: false,
		minHeight: 200.00,
		minWidth: 200.00,
		scale: 1.00,
		scaleMobile: 1.00
		})
	</script>

    <div class="container-fluid">
        <div class="row">
            <div class="col-md-8">
                <nav class="navbar navbar-dark fixed-top navbar-expand-md blur">
                    <a class="navbar-brand" href="https://phungngocminh.github.io/">PHUNG NGOC MINH</a>
                    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <div class="collapse navbar-collapse" id="navbarSupportedContent">
                        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                            <li class="nav-item">
                                <a class="nav-link active" aria-current="page" href="https://phungngocminh.github.io/">
                                    Home
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://phungngocminh.github.io/aquarium">
                                    Aquarium
                                </a>
                            </li>
                            <li class="nav-item">
                                <a class="nav-link" href="https://phungngocminh.github.io/job">
                                    Career ladder
                                </a>
                            </li>
                            <li class="nav-item dropdown">
                                <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    Stuff
                                </a>
                                <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
                                    <li>
                                        <a class="dropdown-item" href="https://phungngocminh.github.io/webgl">
                                            WebGL
                                        </a>
                                    </li>
                                    <li>
                                        <a class="dropdown-item" href="https://phungngocminh.github.io/My_Website/">
                                            My 2024
                                        </a>
                                    </li>   
                                </ul>
                            </li>
                        </ul>
                    </div>
                </nav>
            </div>
            <br> <br>
        </div>
    </div>

    <div class="container">
        <div class="row">
            <div class="col-md-8 header">
                <h1>WELCOME TO PHUNGNGOCMINH.GITHUB.IO/WEBGL</h1>
            </div>
        </div>
        <div class="row">
            <div class="col-md-10">
                <h2 class="header blur">ABOUT THIS</h2>
            </div>
        </div>
        <div class="row">
                <ul>
                    <li>
                        This page is created to demonstrate some WebGL works.
                    </li>
                    <li>
                        I do not own any of these source codes. These are just for education purposes at my school.
                    </li>
                </ul>
        </div>
        <div class="row">
            <div class="col-md-10">
                <h2 class="header blur">
                    Main
                </h2>
            </div>
            <div id="accordion">
                <div class="card">
                    <div class="card-header" id="headingOne">
                        <h5 class="mb-0">
                            <button type="button" class="btn" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                                <h2 class="header blur">Interactive Rotatable Cube</h2>
                            </button>
                        </h5>
                    </div>
                    <div id="collapseOne" class="collapse show" aria-labelledby="headingOne" data-bs-parent="#accordion">
                        <div class="card-body">
                            <div>
                                Author: Edward.
                                <br>
                                Source: <a href="https://www.ojambo.com/build-an-html5-rotating-cube-with-webgl">Edward's Cube</a>
                            </div>
                            <div>
                                <canvas id="glcanvas"></canvas>
                                <script>
                                    // --- Setup ---
                                    const canvas = document.getElementById('glcanvas');
                                    const gl = canvas.getContext('webgl');
                                    if (!gl) alert('WebGL not supported');

                                    function resize() {
                                        const parent = canvas.parentElement;
                                        canvas.width = parent.offsetWidth;
                                        canvas.height = parent.offsetHeight;
                                        gl.viewport(0, 0, canvas.width, canvas.height);
                                    }
                                    window.addEventListener('resize', resize);
                                    resize();

                                    // --- Vertex shader ---
                                    const vsSource = `
                                    attribute vec3 a_position;
                                    attribute vec3 a_normal;

                                    uniform mat4 u_modelViewMatrix;
                                    uniform mat4 u_projectionMatrix;
                                    uniform mat4 u_normalMatrix;

                                    varying vec3 v_normal;
                                    varying vec3 v_position;

                                    void main() {
                                        v_position = (u_modelViewMatrix * vec4(a_position, 1.0)).xyz;
                                        v_normal = mat3(u_normalMatrix) * a_normal;
                                        gl_Position = u_projectionMatrix * vec4(v_position, 1.0);
                                    }
                                    `;

                                    // --- Fragment shader ---
                                    const fsSource = `
                                    precision mediump float;

                                    varying vec3 v_normal;
                                    varying vec3 v_position;

                                    uniform vec3 u_lightPos;
                                    uniform vec3 u_viewPos;
                                    uniform vec4 u_color;

                                    void main() {
                                        vec3 normal = normalize(v_normal);
                                        vec3 lightDir = normalize(u_lightPos - v_position);
                                        vec3 viewDir = normalize(u_viewPos - v_position);

                                        float diff = max(dot(normal, lightDir), 0.0);

                                        vec3 reflectDir = reflect(-lightDir, normal);
                                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);

                                        vec3 ambient = 0.1 * u_color.rgb;
                                        vec3 diffuse = diff * u_color.rgb;
                                        vec3 specular = spec * vec3(1.0);

                                        vec3 color = ambient + diffuse + specular;

                                        gl_FragColor = vec4(color, 0.4);
                                    }
                                    `;

                                    // --- Shader helpers ---
                                    function createShader(gl, type, source) {
                                        const shader = gl.createShader(type);
                                        gl.shaderSource(shader, source);
                                        gl.compileShader(shader);
                                        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                                            console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
                                            gl.deleteShader(shader);
                                            return null;
                                        }
                                        return shader;
                                    }

                                    function createProgram(gl, vs, fs) {
                                        const program = gl.createProgram();
                                        gl.attachShader(program, vs);
                                        gl.attachShader(program, fs);
                                        gl.linkProgram(program);
                                        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                                            console.error('Program link failed:', gl.getProgramInfoLog(program));
                                            return null;
                                        }
                                        return program;
                                    }

                                    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
                                    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
                                    const program = createProgram(gl, vertexShader, fragmentShader);
                                    gl.useProgram(program);

                                    // --- Cube Data ---
                                    const positions = new Float32Array([
                                        // Front
                                        -1, -1, 1,   1, -1, 1,   1, 1, 1,   -1, 1, 1,
                                        // Back
                                        -1, -1,-1,  -1, 1,-1,    1, 1,-1,    1,-1,-1,
                                        // Top
                                        -1, 1,-1,   -1, 1,1,     1, 1,1,     1, 1,-1,
                                        // Bottom
                                        -1,-1,-1,   1,-1,-1,     1,-1,1,    -1,-1,1,
                                        // Right
                                        1,-1,-1,    1,1,-1,      1,1,1,      1,-1,1,
                                        // Left
                                        -1,-1,-1,  -1,-1,1,     -1,1,1,     -1,1,-1,
                                    ]);

                                    const normals = new Float32Array([
                                        // Front
                                        0,0,1, 0,0,1, 0,0,1, 0,0,1,
                                        // Back
                                        0,0,-1,0,0,-1,0,0,-1,0,0,-1,
                                        // Top
                                        0,1,0,0,1,0,0,1,0,0,1,0,
                                        // Bottom
                                        0,-1,0,0,-1,0,0,-1,0,0,-1,0,
                                        // Right
                                        1,0,0,1,0,0,1,0,0,1,0,0,
                                        // Left
                                        -1,0,0,-1,0,0,-1,0,0,-1,0,0,
                                    ]);

                                    const indices = new Uint16Array([
                                        0,1,2, 0,2,3,
                                        4,5,6, 4,6,7,
                                        8,9,10, 8,10,11,
                                        12,13,14, 12,14,15,
                                        16,17,18, 16,18,19,
                                        20,21,22, 20,22,23
                                    ]);

                                    // --- Buffers ---
                                    const posBuffer = gl.createBuffer();
                                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                                    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                                    const normBuffer = gl.createBuffer();
                                    gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
                                    gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

                                    const indexBuffer = gl.createBuffer();
                                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                                    // --- Attributes ---
                                    const posLoc = gl.getAttribLocation(program, 'a_position');
                                    gl.enableVertexAttribArray(posLoc);
                                    gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                                    gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

                                    const normLoc = gl.getAttribLocation(program, 'a_normal');
                                    gl.enableVertexAttribArray(normLoc);
                                    gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
                                    gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);

                                    // --- Uniform Locations ---
                                    const uModelViewMatrixLoc = gl.getUniformLocation(program, 'u_modelViewMatrix');
                                    const uProjectionMatrixLoc = gl.getUniformLocation(program, 'u_projectionMatrix');
                                    const uNormalMatrixLoc = gl.getUniformLocation(program, 'u_normalMatrix');
                                    const uLightPosLoc = gl.getUniformLocation(program, 'u_lightPos');
                                    const uViewPosLoc = gl.getUniformLocation(program, 'u_viewPos');
                                    const uColorLoc = gl.getUniformLocation(program, 'u_color');

                                    // --- Matrix Helpers ---
                                    function createProjectionMatrix(fov, aspect, near, far) {
                                        const f = 1.0 / Math.tan(fov / 2);
                                        const nf = 1 / (near - far);
                                        return new Float32Array([
                                            f/aspect,0,0,0,
                                            0,f,0,0,
                                            0,0,(far+near)*nf,-1,
                                            0,0,(2*far*near)*nf,0
                                        ]);
                                    }

                                    function multiplyMatrices(a, b) {
                                        const out = new Float32Array(16);
                                        for (let i=0;i<4;i++) {
                                            for (let j=0;j<4;j++) {
                                                out[i*4+j] =
                                                    a[0*4+j]*b[i*4+0] +
                                                    a[1*4+j]*b[i*4+1] +
                                                    a[2*4+j]*b[i*4+2] +
                                                    a[3*4+j]*b[i*4+3];
                                            }
                                        }
                                        return out;
                                    }

                                    function identityMatrix() {
                                        return new Float32Array([
                                            1,0,0,0,
                                            0,1,0,0,
                                            0,0,1,0,
                                            0,0,0,1
                                        ]);
                                    }

                                    function translationMatrix(tx, ty, tz) {
                                        const m = identityMatrix();
                                        m[12]=tx; m[13]=ty; m[14]=tz;
                                        return m;
                                    }

                                    function rotationMatrixX(a) {
                                        const c=Math.cos(a), s=Math.sin(a);
                                        return new Float32Array([
                                            1,0,0,0,
                                            0,c,s,0,
                                            0,-s,c,0,
                                            0,0,0,1
                                        ]);
                                    }

                                    function rotationMatrixY(a) {
                                        const c=Math.cos(a), s=Math.sin(a);
                                        return new Float32Array([
                                            c,0,-s,0,
                                            0,1,0,0,
                                            s,0,c,0,
                                            0,0,0,1
                                        ]);
                                    }

                                    function transposeInverse(m) {
                                        const r = new Float32Array(16);
                                        r[0]=m[0]; r[1]=m[4]; r[2]=m[8];
                                        r[4]=m[1]; r[5]=m[5]; r[6]=m[9];
                                        r[8]=m[2]; r[9]=m[6]; r[10]=m[10];
                                        r[3]=0; r[7]=0; r[11]=0; r[15]=1;
                                        return r;
                                    }

                                    // --- Interaction ---
                                    let rotationX=0, rotationY=0;
                                    let dragging=false;
                                    let lastX, lastY;

                                    canvas.addEventListener('mousedown', e=>{
                                        dragging=true;
                                        lastX=e.clientX;
                                        lastY=e.clientY;
                                    });
                                    window.addEventListener('mouseup', ()=> dragging=false);
                                    window.addEventListener('mousemove', e=>{
                                        if (!dragging) return;
                                        const dx=e.clientX-lastX;
                                        const dy=e.clientY-lastY;
                                        rotationY += dx*0.01;
                                        rotationX += dy*0.01;
                                        lastX=e.clientX;
                                        lastY=e.clientY;
                                    });

                                    // --- Render loop ---
                                    function render() {
                                        gl.clearColor(0.05,0.05,0.1,1);
                                        gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                                        gl.enable(gl.DEPTH_TEST);
                                        gl.enable(gl.BLEND);
                                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                                        const aspect = canvas.width / canvas.height;
                                        const proj = createProjectionMatrix(Math.PI/4, aspect, 0.1, 100);

                                        let modelView = translationMatrix(0,0,-6);
                                        modelView = multiplyMatrices(modelView, rotationMatrixX(rotationX));
                                        modelView = multiplyMatrices(modelView, rotationMatrixY(rotationY));

                                        const normalMatrix = transposeInverse(modelView);

                                        gl.uniformMatrix4fv(uProjectionMatrixLoc, false, proj);
                                        gl.uniformMatrix4fv(uModelViewMatrixLoc, false, modelView);
                                        gl.uniformMatrix4fv(uNormalMatrixLoc, false, normalMatrix);

                                        gl.uniform3f(uLightPosLoc,5,5,5);
                                        gl.uniform3f(uViewPosLoc,0,0,0);
                                        gl.uniform4f(uColorLoc,0.2,0.6,1.0,0.4);

                                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                                        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

                                        requestAnimationFrame(render);
                                    }

                                    requestAnimationFrame(render);
                                </script>
                            </div>
                            <div class="box">   <!--    Code snippet box using Prism.js -->
                                <pre>
                                    <code class="language-html line-numbers">
                                        &lt;canvas id=&quot;glcanvas&quot;&gt;&lt;/canvas&gt;
                                        &lt;script&gt;
                                        // --- Setup ---
                                        const canvas = document.getElementById(&#39;glcanvas&#39;);
                                        const gl = canvas.getContext(&#39;webgl&#39;);
                                        if (!gl) alert(&#39;WebGL not supported&#39;);

                                        function resize() {
                                            canvas.width = window.innerWidth;
                                            canvas.height = window.innerHeight;
                                            gl.viewport(0, 0, canvas.width, canvas.height);
                                        }
                                        window.addEventListener(&#39;resize&#39;, resize);
                                        resize();

                                        // --- Vertex shader ---
                                        const vsSource = `
                                        attribute vec3 a_position;
                                        attribute vec3 a_normal;

                                        uniform mat4 u_modelViewMatrix;
                                        uniform mat4 u_projectionMatrix;
                                        uniform mat4 u_normalMatrix;

                                        varying vec3 v_normal;
                                        varying vec3 v_position;

                                        void main() {
                                            v_position = (u_modelViewMatrix * vec4(a_position, 1.0)).xyz;
                                            v_normal = mat3(u_normalMatrix) * a_normal;
                                            gl_Position = u_projectionMatrix * vec4(v_position, 1.0);
                                        }
                                        `;

                                        // --- Fragment shader ---
                                        const fsSource = `
                                        precision mediump float;

                                        varying vec3 v_normal;
                                        varying vec3 v_position;

                                        uniform vec3 u_lightPos;
                                        uniform vec3 u_viewPos;
                                        uniform vec4 u_color;

                                        void main() {
                                            vec3 normal = normalize(v_normal);
                                            vec3 lightDir = normalize(u_lightPos - v_position);
                                            vec3 viewDir = normalize(u_viewPos - v_position);

                                            float diff = max(dot(normal, lightDir), 0.0);

                                            vec3 reflectDir = reflect(-lightDir, normal);
                                            float spec = pow(max(dot(viewDir, reflectDir), 0.0), 64.0);

                                            vec3 ambient = 0.1 * u_color.rgb;
                                            vec3 diffuse = diff * u_color.rgb;
                                            vec3 specular = spec * vec3(1.0);

                                            vec3 color = ambient + diffuse + specular;

                                            gl_FragColor = vec4(color, 0.4);
                                        }
                                        `;

                                        // --- Shader helpers ---
                                        function createShader(gl, type, source) {
                                            const shader = gl.createShader(type);
                                            gl.shaderSource(shader, source);
                                            gl.compileShader(shader);
                                            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                                                console.error(&#39;Shader compile failed:&#39;, gl.getShaderInfoLog(shader));
                                                gl.deleteShader(shader);
                                                return null;
                                            }
                                            return shader;
                                        }

                                        function createProgram(gl, vs, fs) {
                                            const program = gl.createProgram();
                                            gl.attachShader(program, vs);
                                            gl.attachShader(program, fs);
                                            gl.linkProgram(program);
                                            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                                                console.error(&#39;Program link failed:&#39;, gl.getProgramInfoLog(program));
                                                return null;
                                            }
                                            return program;
                                        }

                                        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
                                        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
                                        const program = createProgram(gl, vertexShader, fragmentShader);
                                        gl.useProgram(program);

                                        // --- Cube Data ---
                                        const positions = new Float32Array([
                                            // Front
                                            -1, -1, 1,   1, -1, 1,   1, 1, 1,   -1, 1, 1,
                                            // Back
                                            -1, -1,-1,  -1, 1,-1,    1, 1,-1,    1,-1,-1,
                                            // Top
                                            -1, 1,-1,   -1, 1,1,     1, 1,1,     1, 1,-1,
                                            // Bottom
                                            -1,-1,-1,   1,-1,-1,     1,-1,1,    -1,-1,1,
                                            // Right
                                            1,-1,-1,    1,1,-1,      1,1,1,      1,-1,1,
                                            // Left
                                            -1,-1,-1,  -1,-1,1,     -1,1,1,     -1,1,-1,
                                        ]);

                                        const normals = new Float32Array([
                                            // Front
                                            0,0,1, 0,0,1, 0,0,1, 0,0,1,
                                            // Back
                                            0,0,-1,0,0,-1,0,0,-1,0,0,-1,
                                            // Top
                                            0,1,0,0,1,0,0,1,0,0,1,0,
                                            // Bottom
                                            0,-1,0,0,-1,0,0,-1,0,0,-1,0,
                                            // Right
                                            1,0,0,1,0,0,1,0,0,1,0,0,
                                            // Left
                                            -1,0,0,-1,0,0,-1,0,0,-1,0,0,
                                        ]);

                                        const indices = new Uint16Array([
                                            0,1,2, 0,2,3,
                                            4,5,6, 4,6,7,
                                            8,9,10, 8,10,11,
                                            12,13,14, 12,14,15,
                                            16,17,18, 16,18,19,
                                            20,21,22, 20,22,23
                                        ]);

                                        // --- Buffers ---
                                        const posBuffer = gl.createBuffer();
                                        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                                        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

                                        const normBuffer = gl.createBuffer();
                                        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
                                        gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

                                        const indexBuffer = gl.createBuffer();
                                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

                                        // --- Attributes ---
                                        const posLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
                                        gl.enableVertexAttribArray(posLoc);
                                        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                                        gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);

                                        const normLoc = gl.getAttribLocation(program, &#39;a_normal&#39;);
                                        gl.enableVertexAttribArray(normLoc);
                                        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
                                        gl.vertexAttribPointer(normLoc, 3, gl.FLOAT, false, 0, 0);

                                        // --- Uniform Locations ---
                                        const uModelViewMatrixLoc = gl.getUniformLocation(program, &#39;u_modelViewMatrix&#39;);
                                        const uProjectionMatrixLoc = gl.getUniformLocation(program, &#39;u_projectionMatrix&#39;);
                                        const uNormalMatrixLoc = gl.getUniformLocation(program, &#39;u_normalMatrix&#39;);
                                        const uLightPosLoc = gl.getUniformLocation(program, &#39;u_lightPos&#39;);
                                        const uViewPosLoc = gl.getUniformLocation(program, &#39;u_viewPos&#39;);
                                        const uColorLoc = gl.getUniformLocation(program, &#39;u_color&#39;);

                                        // --- Matrix Helpers ---
                                        function createProjectionMatrix(fov, aspect, near, far) {
                                            const f = 1.0 / Math.tan(fov / 2);
                                            const nf = 1 / (near - far);
                                            return new Float32Array([
                                                f/aspect,0,0,0,
                                                0,f,0,0,
                                                0,0,(far+near)*nf,-1,
                                                0,0,(2*far*near)*nf,0
                                            ]);
                                        }

                                        function multiplyMatrices(a, b) {
                                            const out = new Float32Array(16);
                                            for (let i=0;i&lt;4;i++) {
                                                for (let j=0;j&lt;4;j++) {
                                                    out[i*4+j] =
                                                        a[0*4+j]*b[i*4+0] +
                                                        a[1*4+j]*b[i*4+1] +
                                                        a[2*4+j]*b[i*4+2] +
                                                        a[3*4+j]*b[i*4+3];
                                                }
                                            }
                                            return out;
                                        }

                                        function identityMatrix() {
                                            return new Float32Array([
                                                1,0,0,0,
                                                0,1,0,0,
                                                0,0,1,0,
                                                0,0,0,1
                                            ]);
                                        }

                                        function translationMatrix(tx, ty, tz) {
                                            const m = identityMatrix();
                                            m[12]=tx; m[13]=ty; m[14]=tz;
                                            return m;
                                        }

                                        function rotationMatrixX(a) {
                                            const c=Math.cos(a), s=Math.sin(a);
                                            return new Float32Array([
                                                1,0,0,0,
                                                0,c,s,0,
                                                0,-s,c,0,
                                                0,0,0,1
                                            ]);
                                        }

                                        function rotationMatrixY(a) {
                                            const c=Math.cos(a), s=Math.sin(a);
                                            return new Float32Array([
                                                c,0,-s,0,
                                                0,1,0,0,
                                                s,0,c,0,
                                                0,0,0,1
                                            ]);
                                        }

                                        function transposeInverse(m) {
                                            const r = new Float32Array(16);
                                            r[0]=m[0]; r[1]=m[4]; r[2]=m[8];
                                            r[4]=m[1]; r[5]=m[5]; r[6]=m[9];
                                            r[8]=m[2]; r[9]=m[6]; r[10]=m[10];
                                            r[3]=0; r[7]=0; r[11]=0; r[15]=1;
                                            return r;
                                        }

                                        // --- Interaction ---
                                        let rotationX=0, rotationY=0;
                                        let dragging=false;
                                        let lastX, lastY;

                                        canvas.addEventListener(&#39;mousedown&#39;, e=&gt;{
                                            dragging=true;
                                            lastX=e.clientX;
                                            lastY=e.clientY;
                                        });
                                        window.addEventListener(&#39;mouseup&#39;, ()=&gt; dragging=false);
                                        window.addEventListener(&#39;mousemove&#39;, e=&gt;{
                                            if (!dragging) return;
                                            const dx=e.clientX-lastX;
                                            const dy=e.clientY-lastY;
                                            rotationY += dx*0.01;
                                            rotationX += dy*0.01;
                                            lastX=e.clientX;
                                            lastY=e.clientY;
                                        });

                                        // --- Render loop ---
                                        function render() {
                                            gl.clearColor(0.05,0.05,0.1,1);
                                            gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                                            gl.enable(gl.DEPTH_TEST);
                                            gl.enable(gl.BLEND);
                                            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

                                            const aspect = canvas.width / canvas.height;
                                            const proj = createProjectionMatrix(Math.PI/4, aspect, 0.1, 100);

                                            let modelView = translationMatrix(0,0,-6);
                                            modelView = multiplyMatrices(modelView, rotationMatrixX(rotationX));
                                            modelView = multiplyMatrices(modelView, rotationMatrixY(rotationY));

                                            const normalMatrix = transposeInverse(modelView);

                                            gl.uniformMatrix4fv(uProjectionMatrixLoc, false, proj);
                                            gl.uniformMatrix4fv(uModelViewMatrixLoc, false, modelView);
                                            gl.uniformMatrix4fv(uNormalMatrixLoc, false, normalMatrix);

                                            gl.uniform3f(uLightPosLoc,5,5,5);
                                            gl.uniform3f(uViewPosLoc,0,0,0);
                                            gl.uniform4f(uColorLoc,0.2,0.6,1.0,0.4);

                                            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                                            gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);

                                            requestAnimationFrame(render);
                                        }

                                        requestAnimationFrame(render);
                                        &lt;/script&gt;

                                    </code>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header" id="headingThree">
                        <h5 class="mb-0">
                            <button type="button" class="btn collapsed" data-bs-toggle="collapse" data-bs-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                                <h2 class="header blur">Dream Workspace</h2>
                            </button>
                        </h5>
                    </div>
                    <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-bs-parent="#accordion">
                        <div class="card-body">
                            <div>
                                Author: Ricardo Oliva Alonso.
                                <br>
                                Source: <a href="https://codepen.io/ricardoolivaalonso/pen/poYEpwP">Ricardo's Diorama</a>
                            </div>
                            <div>
                                
                                    <canvas class="webgl"></canvas>
    <div id="loader">
        <h1>Loading</h1>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const loading = document.querySelector('#loader')

        const canvas3 = document.querySelector('.webgl')
        const scene = new THREE.Scene()
        const textureLoader = new THREE.TextureLoader()
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight
        }

        // Base camera
        const camera = new THREE.PerspectiveCamera(10, sizes.width / sizes.height, 0.1, 100)
        camera.position.x = 8
        camera.position.y = 4
        camera.position.z = 15
        scene.add(camera)

        //Controls
        const controls = new THREE.OrbitControls(camera, canvas3)
        controls.enableDamping = true
        controls.enableZoom = true
        controls.enablePan = true
        controls.minDistance = 21
        controls.maxDistance = 50
        controls.minPolarAngle = Math.PI / 5
        controls.maxPolarAngle = Math.PI / 2

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas3,
            antialias: true,
            alpha: true
        })

        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.outputEncoding = THREE.sRGBEncoding

        // Materials
        const bakedTexture = textureLoader.load('https://rawcdn.githack.com/ricardoolivaalonso/ThreeJS-Room13/47b05e2db4e49eec33d63729e920894a906cb693/static/baked.jpg')
        bakedTexture.flipY = false
        bakedTexture.encoding = THREE.sRGBEncoding

        const bakedMaterial = new THREE.MeshBasicMaterial({ map: bakedTexture })

        //Loader
        const loader = new THREE.GLTFLoader()
        loader.load('https://rawcdn.githack.com/ricardoolivaalonso/ThreeJS-Room13/47b05e2db4e49eec33d63729e920894a906cb693/static/model.glb',
            (gltf) => {
                const model = gltf.scene
                model.traverse(child => child.material = bakedMaterial)
                scene.add(model)
                scene.position.set(0, .2, 0)
                loading.style.display = 'none'

            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded')
            }
        )


        window.addEventListener('resize', () => {
            sizes.width = window.innerWidth
            sizes.height = window.innerHeight
            camera.aspect = sizes.width / sizes.height
            camera.updateProjectionMatrix()
            renderer.setSize(sizes.width, sizes.height)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        })
        // Animation

        var minPan = new THREE.Vector3(-2, -.5, -2)
        var maxPan = new THREE.Vector3(2, .5, 2)

        const tick = () => {
            controls.update()
            controls.target.clamp(minPan, maxPan)
            renderer.render(scene, camera)
            window.requestAnimationFrame(tick)
        }

        tick()

    </script>
                            </div>
                            <div class="box">
                                <pre>
                                    <code class="language-html line-numbers">
                                        &lt;canvas class=&quot;webgl&quot;&gt;&lt;/canvas&gt;
    &lt;div id=&quot;loader&quot;&gt;
        &lt;h1&gt;Loading&lt;/h1&gt;
    &lt;/div&gt;

    &lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;https://unpkg.com/three@0.126.0/examples/js/controls/OrbitControls.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        const loading = document.querySelector('#loader')

        const canvas = document.querySelector('.webgl')
        const scene = new THREE.Scene()
        const textureLoader = new THREE.TextureLoader()
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight
        }

        // Base camera
        const camera = new THREE.PerspectiveCamera(10, sizes.width / sizes.height, 0.1, 100)
        camera.position.x = 8
        camera.position.y = 4
        camera.position.z = 15
        scene.add(camera)

        //Controls
        const controls = new THREE.OrbitControls(camera, canvas)
        controls.enableDamping = true
        controls.enableZoom = true
        controls.enablePan = true
        controls.minDistance = 21
        controls.maxDistance = 50
        controls.minPolarAngle = Math.PI / 5
        controls.maxPolarAngle = Math.PI / 2

        // Renderer
        const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            antialias: true,
            alpha: true
        })

        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        renderer.outputEncoding = THREE.sRGBEncoding

        // Materials
        const bakedTexture = textureLoader.load('https://rawcdn.githack.com/ricardoolivaalonso/ThreeJS-Room13/47b05e2db4e49eec33d63729e920894a906cb693/static/baked.jpg')
        bakedTexture.flipY = false
        bakedTexture.encoding = THREE.sRGBEncoding

        const bakedMaterial = new THREE.MeshBasicMaterial({ map: bakedTexture })

        //Loader
        const loader = new THREE.GLTFLoader()
        loader.load('https://rawcdn.githack.com/ricardoolivaalonso/ThreeJS-Room13/47b05e2db4e49eec33d63729e920894a906cb693/static/model.glb',
            (gltf) =&gt; {
                const model = gltf.scene
                model.traverse(child =&gt; child.material = bakedMaterial)
                scene.add(model)
                scene.position.set(0, .2, 0)
                loading.style.display = 'none'

            },
            (xhr) =&gt; {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded')
            }
        )


        window.addEventListener('resize', () =&gt; {
            sizes.width = window.innerWidth
            sizes.height = window.innerHeight
            camera.aspect = sizes.width / sizes.height
            camera.updateProjectionMatrix()
            renderer.setSize(sizes.width, sizes.height)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
        })
        // Animation

        var minPan = new THREE.Vector3(-2, -.5, -2)
        var maxPan = new THREE.Vector3(2, .5, 2)

        const tick = () =&gt; {
            controls.update()
            controls.target.clamp(minPan, maxPan)
            renderer.render(scene, camera)
            window.requestAnimationFrame(tick)
        }

        tick()

    &lt;/script&gt;

                                    </code>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header" id="headingFour">
                        <h5 class="mb-0">
                            <button type="button" class="btn collapsed" data-bs-toggle="collapse" data-bs-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
                                <h2 class="header blur">Happy Canvas</h2>
                            </button>
                        </h5>
                    </div>
                    <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-bs-parent="#accordion">
                        <div class="card-body">
                            <div>
                                Author: Greggman.
                                <br>
                                Source: <a href="https://github.com/greggman/webgl-boilerplate">Greggman's Boilerplate</a>
                            </div>
                            <div>

                                		<canvas id="canvas4" style="height: 100%; width: 1250px"></canvas>
		<div id="info"></div> 
 
		<script id="vs" type="x-shader/vertex"> 
 
			attribute vec3 position;
 
			void main() {
 
				gl_Position = vec4( position, 1.0 );
 
			}
 
		</script> 
 
		<script id="fs" type="x-shader/fragment"> 
 
			uniform float time;
			uniform vec2 resolution;
 
			void main( void ) {
 
				vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
				float red = abs( sin( position.x * position.y + time / 5.0 ) );
				float green = abs( sin( position.x * position.y + time / 4.0 ) );
				float blue = abs( sin( position.x * position.y + time / 3.0 ) );
				gl_FragColor = vec4( red, green, blue, 1.0 );
 
			}
 
		</script> 
 
		<script> 
            (function() {
			/**
			 * Provides requestAnimationFrame in a cross browser way.
			 * paulirish.com/2011/requestanimationframe-for-smart-animating/
			 */
			window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

				return  window.webkitRequestAnimationFrame ||
				        window.mozRequestAnimationFrame ||
				        window.oRequestAnimationFrame ||
				        window.msRequestAnimationFrame ||
				        function(  callback, element ) {
					        window.setTimeout( callback, 1000 / 60 );
				        };

			})();

 
			let canvas,
			    gl, 
			    buffer, 
			    vertex_shader, fragment_shader, 
			    currentProgram,
			    vertex_position, 
			    parameters = {  start_time  : new Date().getTime(), 
			                    time        : 0, 
			                    screenWidth : 0, 
			                    screenHeight: 0 };
 
			init();
			animate();
 
			function init() {
 
				vertex_shader = document.getElementById('vs').textContent;
				fragment_shader = document.getElementById('fs').textContent;
 

 
                canvas = document.querySelector( '#canvas4' );
 
				// Initialise WebGL
 
				try {
 
					gl = canvas.getContext( 'experimental-webgl' );
 
				} catch( error ) { }
 
				if ( !gl ) {
 
					throw "cannot create webgl context";
 
				}
 
				// Create Vertex buffer (2 triangles)
 
				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );
 
				// Create Program
 
				currentProgram = createProgram( vertex_shader, fragment_shader );
 
				onWindowResize();
				window.addEventListener( 'resize', onWindowResize, false );
 
			}
 
			function createProgram( vertex, fragment ) {
 
				var program = gl.createProgram();
 
				var vs = createShader( vertex, gl.VERTEX_SHADER );
				var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );
 
				if ( vs == null || fs == null ) return null;
 
				gl.attachShader( program, vs );
				gl.attachShader( program, fs );
 
				gl.deleteShader( vs );
				gl.deleteShader( fs );
 
				gl.linkProgram( program );
 
				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
 
					alert( "ERROR:\n" +
					"VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"ERROR: " + gl.getError() + "\n\n" +
					"- Vertex Shader -\n" + vertex + "\n\n" +
					"- Fragment Shader -\n" + fragment );
 
					return null;
 
				}
 
				return program;
 
			}
 
			function createShader( src, type ) {
 
				var shader = gl.createShader( type );
 
				gl.shaderSource( shader, src );
				gl.compileShader( shader );
 
				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
 
					alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
					return null;
 
				}
 
				return shader;
 
			}
 
			function onWindowResize( event ) {
 
				canvas.width = window.innerWidth;
				canvas.height = window.innerHeight;
 
				parameters.screenWidth = canvas.width;
				parameters.screenHeight = canvas.height;
 
				gl.viewport( 0, 0, canvas.width, canvas.height );
 
			}
 
			function animate() {
 
				requestAnimationFrame( animate );
				render();
 
			}
 
			function render() {
 
				if ( !currentProgram ) return;
 
				parameters.time = new Date().getTime() - parameters.start_time;
 
				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
 
				// Load program into GPU
 
				gl.useProgram( currentProgram );
 
				// Set values to program variables
 
				gl.uniform1f( gl.getUniformLocation( currentProgram, 'time' ), parameters.time / 1000 );
				gl.uniform2f( gl.getUniformLocation( currentProgram, 'resolution' ), parameters.screenWidth, parameters.screenHeight );
 
				// Render geometry
 
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );
 
			}
            })();
		</script> 

                            </div>
                            <div class="box">
                                <pre>
                                    <code class="language-html line-numbers">
&lt;canvas&gt;&lt;/canvas&gt;
&lt;div id="info"&gt;&lt;/div&gt;

&lt;script id="vs" type="x-shader/vertex"&gt;

    attribute vec3 position;

    void main() {

        gl_Position = vec4( position, 1.0 );

    }

&lt;/script&gt;

&lt;script id="fs" type="x-shader/fragment"&gt;

    uniform float time;
    uniform vec2 resolution;

    void main( void ) {

        vec2 position = - 1.0 + 2.0 * gl_FragCoord.xy / resolution.xy;
        float red = abs( sin( position.x * position.y + time / 5.0 ) );
        float green = abs( sin( position.x * position.y + time / 4.0 ) );
        float blue = abs( sin( position.x * position.y + time / 3.0 ) );
        gl_FragColor = vec4( red, green, blue, 1.0 );

    }

&lt;/script&gt;

&lt;script&gt;

    /**
     * Provides requestAnimationFrame in a cross browser way.
     * paulirish.com/2011/requestanimationframe-for-smart-animating/
     */
    window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

        return  window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(  callback, element ) {
                    window.setTimeout( callback, 1000 / 60 );
                };

    })();


    var canvas, 
        gl, 
        buffer, 
        vertex_shader, fragment_shader, 
        currentProgram,
        vertex_position, 
        parameters = {  start_time  : new Date().getTime(), 
                        time        : 0, 
                        screenWidth : 0, 
                        screenHeight: 0 };

    init();
    animate();

    function init() {

        vertex_shader = document.getElementById('vs').textContent;
        fragment_shader = document.getElementById('fs').textContent;

        canvas = document.querySelector( 'canvas' );

        // Initialise WebGL

        try {

            gl = canvas.getContext( 'experimental-webgl' );

        } catch( error ) { }

        if ( !gl ) {

            throw "cannot create webgl context";

        }

        // Create Vertex buffer (2 triangles)

        buffer = gl.createBuffer();
        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

        // Create Program

        currentProgram = createProgram( vertex_shader, fragment_shader );

        onWindowResize();
        window.addEventListener( 'resize', onWindowResize, false );

    }

    function createProgram( vertex, fragment ) {

        var program = gl.createProgram();

        var vs = createShader( vertex, gl.VERTEX_SHADER );
        var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );

        if ( vs == null || fs == null ) return null;

        gl.attachShader( program, vs );
        gl.attachShader( program, fs );

        gl.deleteShader( vs );
        gl.deleteShader( fs );

        gl.linkProgram( program );

        if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

            alert( "ERROR:\n" +
            "VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
            "ERROR: " + gl.getError() + "\n\n" +
            "- Vertex Shader -\n" + vertex + "\n\n" +
            "- Fragment Shader -\n" + fragment );

            return null;

        }

        return program;

    }

    function createShader( src, type ) {

        var shader = gl.createShader( type );

        gl.shaderSource( shader, src );
        gl.compileShader( shader );

        if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

            alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
            return null;

        }

        return shader;

    }

    function onWindowResize( event ) {

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        parameters.screenWidth = canvas.width;
        parameters.screenHeight = canvas.height;

        gl.viewport( 0, 0, canvas.width, canvas.height );

    }

    function animate() {

        requestAnimationFrame( animate );
        render();

    }

    function render() {

        if ( !currentProgram ) return;

        parameters.time = new Date().getTime() - parameters.start_time;

        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

        // Load program into GPU

        gl.useProgram( currentProgram );

        // Set values to program variables

        gl.uniform1f( gl.getUniformLocation( currentProgram, 'time' ), parameters.time / 1000 );
        gl.uniform2f( gl.getUniformLocation( currentProgram, 'resolution' ), parameters.screenWidth, parameters.screenHeight );

        // Render geometry

        gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
        gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
        gl.enableVertexAttribArray( vertex_position );
        gl.drawArrays( gl.TRIANGLES, 0, 6 );
        gl.disableVertexAttribArray( vertex_position );

    }

&lt;/script&gt;
                                    </code>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header" id="headingFive">
                        <h5 class="mb-0">
                            <button type="button" class="btn collapsed" data-bs-toggle="collapse" data-bs-target="#collapseFive" aria-expanded="false" aria-controls="collapseFour">
                                <h2 class="header blur">Bouncy Spinning Square</h2>
                            </button>
                        </h5>
                    </div>
                    <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-bs-parent="#accordion">
                        <div class="card-body">
                            <div>
                                Author: Scott Smitelli.
                                <br>
                                Source: <a href="https://www.scottsmitelli.com/articles/small-webgl-examples/">Scott's Square</a>
                            </div>
                            <div id="canvas5">
                                <canvas id="gl-square"></canvas>
                                <script>
                                    (function() {
                                    const CANVAS_ID = 'gl-square';
    const VERTICES = new Float32Array([
        // X     Y   R   G   B
        -0.2,  0.2,  1,  0,  0,
         0.2,  0.2,  0,  1,  0,
        -0.2, -0.2,  0,  0,  1,
         0.2, -0.2,  1,  1,  0]);
    const VERT_SZ = VERTICES.BYTES_PER_ELEMENT;
    let xpos = -1, xdir = 0, ypos = -1, ydir = 0, program;

    addEventListener('load', () => {
        const gl = document.getElementById(CANVAS_ID).getContext('webgl2');
        program = gl.createProgram();

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader,
            `#version 300 es
            in vec2 position;
            in vec3 color;
            uniform mat4 transform;
            out vec3 vertcolor;
            void main() {
                gl_Position = transform * vec4(position, 0, 1);
                vertcolor = color;
            }`
        );
        gl.compileShader(vertexShader);
        gl.attachShader(program, vertexShader);
        gl.deleteShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader,
            `#version 300 es
            precision highp float;
            in vec3 vertcolor;
            out vec4 fragcolor;
            void main() {
                fragcolor = vec4(vertcolor, 1);
            }`
        );
        gl.compileShader(fragmentShader);
        gl.attachShader(program, fragmentShader);
        gl.deleteShader(fragmentShader);

        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, VERTICES, gl.STATIC_DRAW);

        let loc = gl.getAttribLocation(program, 'position');
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false,  5 * VERT_SZ, 0);
        gl.enableVertexAttribArray(loc);

        loc = gl.getAttribLocation(program, 'color');
        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false,  5 * VERT_SZ,  2 * VERT_SZ);
        gl.enableVertexAttribArray(loc);

        requestAnimationFrame(do_frame);
    });

    function do_frame(now_ms) {
        const canvas = document.getElementById(CANVAS_ID);
        const gl = canvas.getContext('webgl2');

        if (canvas.width !== canvas.parentElement.offsetWidth) {
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.width;
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        const theta = ((now_ms / 1000) % 1) * -(Math.PI * 2);
        const mat = new Float32Array([
             Math.cos(theta), Math.sin(theta), 0,               0,
            -Math.sin(theta), Math.cos(theta), 0,               0,
             0,               0,               1,               0,
             xpos,            ypos,            0,               1]);

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'transform'), false, mat);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        if (xpos <= -1) xdir = 1; else if (xpos >= 1) xdir = -1;
        if (ypos <= -1) ydir = 1; else if (ypos >= 1) ydir = -1;

        xpos += xdir * 0.01;
        ypos += ydir * 0.021;  //break up the monotony

        requestAnimationFrame(do_frame);
    }
    })();
                                </script>
                            </div>
                            <div class="box">
                                <pre>
                                    <code class="language-html line-numbers">
                                        &lt;canvas id="gl-square"&gt;&lt;/canvas&gt;
&lt;script&gt;
const CANVAS_ID = 'gl-square';
    const VERTICES = new Float32Array([
        // X     Y   R   G   B
        -0.2,  0.2,  1,  0,  0,
         0.2,  0.2,  0,  1,  0,
        -0.2, -0.2,  0,  0,  1,
         0.2, -0.2,  1,  1,  0]);
    const VERT_SZ = VERTICES.BYTES_PER_ELEMENT;
    let xpos = -1, xdir = 0, ypos = -1, ydir = 0, program;

    addEventListener('load', () => {
        const gl = document.getElementById(CANVAS_ID).getContext('webgl2');
        program = gl.createProgram();

        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader,
            `#version 300 es
            in vec2 position;
            in vec3 color;
            uniform mat4 transform;
            out vec3 vertcolor;
            void main() {
                gl_Position = transform * vec4(position, 0, 1);
                vertcolor = color;
            }`
        );
        gl.compileShader(vertexShader);
        gl.attachShader(program, vertexShader);
        gl.deleteShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader,
            `#version 300 es
            precision highp float;
            in vec3 vertcolor;
            out vec4 fragcolor;
            void main() {
                fragcolor = vec4(vertcolor, 1);
            }`
        );
        gl.compileShader(fragmentShader);
        gl.attachShader(program, fragmentShader);
        gl.deleteShader(fragmentShader);

        gl.linkProgram(program);
        gl.useProgram(program);

        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, VERTICES, gl.STATIC_DRAW);

        let loc = gl.getAttribLocation(program, 'position');
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false,  5 * VERT_SZ, 0);
        gl.enableVertexAttribArray(loc);

        loc = gl.getAttribLocation(program, 'color');
        gl.vertexAttribPointer(loc, 3, gl.FLOAT, false,  5 * VERT_SZ,  2 * VERT_SZ);
        gl.enableVertexAttribArray(loc);

        requestAnimationFrame(do_frame);
    });

    function do_frame(now_ms) {
        const canvas = document.getElementById(CANVAS_ID);
        const gl = canvas.getContext('webgl2');

        if (canvas.width !== canvas.parentElement.offsetWidth) {
            canvas.width = canvas.parentElement.offsetWidth;
            canvas.height = canvas.width;
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }

        const theta = ((now_ms / 1000) % 1) * -(Math.PI * 2);
        const mat = new Float32Array([
             Math.cos(theta), Math.sin(theta), 0,               0,
            -Math.sin(theta), Math.cos(theta), 0,               0,
             0,               0,               1,               0,
             xpos,            ypos,            0,               1]);

        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'transform'), false, mat);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        if (xpos &lt;= -1) xdir = 1; else if (xpos &gt;= 1) xdir = -1;
        if (ypos &lt;= -1) ydir = 1; else if (ypos &gt;= 1) ydir = -1;

        xpos += xdir * 0.01;
        ypos += ydir * 0.021;  //break up the monotony

        requestAnimationFrame(do_frame);
    }
&lt;/script&gt;
                                    </code>
                                </pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        
    </div>
</body>
</html>

    <script>
        // If you've copied the demo code into this page, some scripts may have
        // been added after the browser's DOMContentLoaded event. Call initDemo()
        // explicitly when available so the canvas is initialized.
        (function(){
            if (typeof initDemo === 'function') {
                try {
                    initDemo();
                    console.log('initDemo invoked');
                } catch (e) {
                    console.error('Error while calling initDemo()', e);
                }
            } else {
                console.log('initDemo not defined  ensure the demo script is included before this call.');
            }
        })();
    </script>
